import express from 'express';
import cors from 'cors';
import { PrismaClient } from '@prisma/client';
import { Solar } from 'lunar-javascript';

const prisma = new PrismaClient();
const app = express();
const PORT = process.env.PORT || 4000;
console.log('--- SERVER STARTING: FIX APPLIED ---');

app.use(cors());
app.use(express.json());

// --- Mappings & Constants ---

// Pinyin and Element mappings for Stems (TianGan)
const STEMS_MAP = {
  'ç”²': { name: 'Jia', element: 'Wood', polarity: '+' },
  'ä¹™': { name: 'Yi', element: 'Wood', polarity: '-' },
  'ä¸™': { name: 'Bing', element: 'Fire', polarity: '+' },
  'ä¸': { name: 'Ding', element: 'Fire', polarity: '-' },
  'æˆŠ': { name: 'Wu', element: 'Earth', polarity: '+' },
  'å·±': { name: 'Ji', element: 'Earth', polarity: '-' },
  'åºš': { name: 'Geng', element: 'Metal', polarity: '+' },
  'è¾›': { name: 'Xin', element: 'Metal', polarity: '-' },
  'å£¬': { name: 'Ren', element: 'Water', polarity: '+' },
  'ç™¸': { name: 'Gui', element: 'Water', polarity: '-' },
};

// Pinyin and Element mappings for Branches (DiZhi)
const BRANCHES_MAP = {
  'å­': { name: 'Zi', element: 'Water', polarity: '+' }, // Standard Polarity for rendering/basic logic
  'ä¸‘': { name: 'Chou', element: 'Earth', polarity: '-' },
  'å¯…': { name: 'Yin', element: 'Wood', polarity: '+' },
  'å¯': { name: 'Mao', element: 'Wood', polarity: '-' },
  'è¾°': { name: 'Chen', element: 'Earth', polarity: '+' },
  'å·³': { name: 'Si', element: 'Fire', polarity: '-' },
  'åˆ': { name: 'Wu', element: 'Fire', polarity: '+' },
  'æœª': { name: 'Wei', element: 'Earth', polarity: '-' },
  'ç”³': { name: 'Shen', element: 'Metal', polarity: '+' },
  'é…‰': { name: 'You', element: 'Metal', polarity: '-' },
  'æˆŒ': { name: 'Xu', element: 'Earth', polarity: '+' },
  'äº¥': { name: 'Hai', element: 'Water', polarity: '-' },
};

// Five Elements Generating/Controlling relationships
// Generated order: Wood -> Fire -> Earth -> Metal -> Water -> Wood
// Controlled order: Wood -> Earth -> Water -> Fire -> Metal -> Wood
const ELEMENTS = ['Wood', 'Fire', 'Earth', 'Metal', 'Water'];

function getElementRelation(me, other) {
  if (me === other) return 'Same';

  const meIdx = ELEMENTS.indexOf(me);
  const otherIdx = ELEMENTS.indexOf(other);

  // Generating: me generates other?
  if ((meIdx + 1) % 5 === otherIdx) return 'Generates';
  // Generated by: other generates me?
  if ((otherIdx + 1) % 5 === meIdx) return 'GeneratedBy';
  // Controlling: me controls other?
  if ((meIdx + 2) % 5 === otherIdx) return 'Controls';
  // Controlled by: other controls me?
  if ((otherIdx + 2) % 5 === meIdx) return 'ControlledBy';

  return 'Unknown';
}

function calculateTenGod(dayMasterStemVal, targetStemVal) {
  const dm = STEMS_MAP[dayMasterStemVal];
  const target = STEMS_MAP[targetStemVal];

  if (!dm || !target) return 'Unknown';

  const relation = getElementRelation(dm.element, target.element);
  const samePolarity = dm.polarity === target.polarity;

  switch (relation) {
    case 'Same':
      return samePolarity ? 'Friend (Bi Jian)' : 'Rob Wealth (Jie Cai)';
    case 'Generates':
      return samePolarity ? 'Eating God (Shi Shen)' : 'Hurting Officer (Shang Guan)';
    case 'GeneratedBy':
      return samePolarity ? 'Indirect Resource (Pian Yin)' : 'Direct Resource (Zheng Yin)';
    case 'Controls':
      return samePolarity ? 'Indirect Wealth (Pian Cai)' : 'Direct Wealth (Zheng Cai)';
    case 'ControlledBy':
      return samePolarity ? 'Seven Killings (Qi Sha)' : 'Direct Officer (Zheng Guan)';
    default:
      return 'Unknown';
  }
}

// Helper to map a single pillar (Gan + Zhi)
function buildPillar(ganChar, zhiChar) {
  const ganInfo = STEMS_MAP[ganChar] || { name: ganChar, element: 'Unknown' };
  const zhiInfo = BRANCHES_MAP[zhiChar] || { name: zhiChar, element: 'Unknown' };

  return {
    stem: ganInfo.name,
    branch: zhiInfo.name,
    elementStem: ganInfo.element,
    elementBranch: zhiInfo.element,
    charStem: ganChar, // Internal use
    charBranch: zhiChar // Internal use
  };
}

const requireAuth = async (req, res, next) => {
  const auth = req.headers.authorization || '';
  const token = auth.startsWith('Bearer ') ? auth.slice(7) : null;
  if (!token) return res.status(401).json({ error: 'Unauthorized' });

  // Naive token parsing (In prod, use verify)
  const match = token.match(/^token_(\d+)_/);
  if (!match) return res.status(401).json({ error: 'Invalid token' });

  const userId = Number(match[1]);
  const user = await prisma.user.findUnique({ where: { id: userId } });
  if (!user) return res.status(401).json({ error: 'User not found' });

  req.user = { id: user.id, email: user.email, name: user.name };
  next();
};

const serializeRecord = (record) => ({
  ...record,
  pillars: JSON.parse(record.pillars),
  fiveElements: JSON.parse(record.fiveElements),
  tenGods: record.tenGods ? JSON.parse(record.tenGods) : null,
  luckCycles: record.luckCycles ? JSON.parse(record.luckCycles) : null,
});

// --- Core Calculation ---

const performCalculation = (data) => {
  const { birthYear, birthMonth, birthDay, birthHour, gender } = data;

  // Create Solar date. Lunar-javascript expects month 1-12.
  const solar = Solar.fromYmdHms(birthYear, birthMonth, birthDay, birthHour, 0, 0);
  const lunar = solar.getLunar();
  const eightChar = lunar.getEightChar();

  // 1. Pillars
  const yearPillar = buildPillar(eightChar.getYearGan(), eightChar.getYearZhi());
  const monthPillar = buildPillar(eightChar.getMonthGan(), eightChar.getMonthZhi());
  const dayPillar = buildPillar(eightChar.getDayGan(), eightChar.getDayZhi());
  const hourPillar = buildPillar(eightChar.getTimeGan(), eightChar.getTimeZhi());

  const pillars = {
    year: yearPillar,
    month: monthPillar,
    day: dayPillar,
    hour: hourPillar,
  };

  // 2. Five Elements Count
  // Count elements from Stems and Branches
  const counts = { Wood: 0, Fire: 0, Earth: 0, Metal: 0, Water: 0 };
  const addCount = (el) => { if (counts[el] !== undefined) counts[el]++; };

  [yearPillar, monthPillar, dayPillar, hourPillar].forEach(p => {
    addCount(p.elementStem);
    addCount(p.elementBranch);
  });

  // 3. Ten Gods (Stems relative to Day Master)
  // We calculate Ten Gods for the generated Stems (Year, Month, Hour) relative to Day Stem.
  // We can also calculate for Branch Main Qi if we want, but for now stick to simple structure.
  // The frontend expects a list of { name, strength }.
  // Current logic in frontend is displaying them as a list.
  // We will provide a list of Ten Gods present in the Stems? Or all 10 types?
  // The previous mock returned all 10 types with strengths.
  // To be helpful, we can calculate the strength based on how many times that Ten God appears (simplified).

  const dayMasterChar = eightChar.getDayGan();
  const tenGodsCounts = {};

  // Initialize counts
  const allTenGodsTypes = [
    'Friend (Bi Jian)', 'Rob Wealth (Jie Cai)',
    'Eating God (Shi Shen)', 'Hurting Officer (Shang Guan)',
    'Indirect Wealth (Pian Cai)', 'Direct Wealth (Zheng Cai)',
    'Seven Killings (Qi Sha)', 'Direct Officer (Zheng Guan)',
    'Indirect Resource (Pian Yin)', 'Direct Resource (Zheng Yin)'
  ];
  allTenGodsTypes.forEach(t => tenGodsCounts[t] = 0);

  // Scan all stems and branches to count Ten Gods
  // For stems: direct relationship
  // For branches: use the main element/hidden stem? Simplified: use branch element.

  const scanParts = [
    yearPillar.charStem, yearPillar.charBranch,
    monthPillar.charStem, monthPillar.charBranch,
    // dayPillar.charStem is Self (Day Master), usually not counted as Ten God or counted as Friend?
    // Usually Day Master is not its own Ten God.
    dayPillar.charBranch,
    hourPillar.charStem, hourPillar.charBranch
  ];

  // Helper to get element of char to find pseudo-TenGod for Branch
  const getCharStemEquivalent = (char) => {
    // If it is a Stem, return it.
    if (STEMS_MAP[char]) return char;
    // If Branch, convert to Main Qi Stem (Simplified)
    // This is a rough approximation for the strength chart.
    const branchToMainQi = {
      'å­': 'ç™¸', 'ä¸‘': 'å·±', 'å¯…': 'ç”²', 'å¯': 'ä¹™', 'è¾°': 'æˆŠ', 'å·³': 'ä¸™',
      'åˆ': 'ä¸', 'æœª': 'å·±', 'ç”³': 'åºš', 'é…‰': 'è¾›', 'æˆŒ': 'æˆŠ', 'äº¥': 'å£¬'
    };
    return branchToMainQi[char];
  };

  scanParts.forEach(char => {
    const stemVal = getCharStemEquivalent(char);
    if (stemVal) {
      const tg = calculateTenGod(dayMasterChar, stemVal);
      if (tenGodsCounts[tg] !== undefined) {
        tenGodsCounts[tg] += 10; // Add score
      } else if (tg.includes('Friend')) {
        // Self
        tenGodsCounts['Friend (Bi Jian)'] += 10;
      }
    }
  });

  // Map to array
  const tenGods = Object.entries(tenGodsCounts).map(([name, val]) => ({
    name, strength: val
  }));

  // 4. Luck Cycles (Da Yun)
  // lunar-javascript: gender 1=man, 0=woman
  const genderInt = gender === 'male' ? 1 : 0;
  const yun = eightChar.getYun(genderInt);
  const daYunArr = yun.getDaYun();

  // We usually take first 8-10 cycles
  // DaYun object has: getStartYear(), getStartAge(), getGanZhi()
  const luckCycles = daYunArr.slice(1, 9).map(dy => { // Start from index 1 usually as index 0 is 0-agg
    const startAge = dy.getStartAge();
    const endAge = dy.getEndAge();
    const ganZhi = dy.getGanZhi();
    // Split GanZhi (e.g. "ç”²å­")
    const gan = ganZhi.substring(0, 1);
    const zhi = ganZhi.substring(1, 2);
    const stemInfo = STEMS_MAP[gan] || { name: gan };
    const zhiInfo = BRANCHES_MAP[zhi] || { name: zhi };

    return {
      range: `${startAge}-${endAge}`,
      stem: stemInfo.name,
      branch: zhiInfo.name
    };
  });

  return { pillars, fiveElements: counts, tenGods, luckCycles };
};

// --- Routes ---

app.get('/health', (req, res) => res.json({ status: 'ok' }));

app.post('/api/register', async (req, res) => {
  const { email, password, name } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'Email and password required' });

  try {
    const user = await prisma.user.create({ data: { email, password, name } });
    res.json({ message: 'User created', user });
  } catch (error) {
    if (error.code === 'P2002') res.status(409).json({ error: 'Email already exists' });
    else { console.error(error); res.status(500).json({ error: 'Internal server error' }); }
  }
});

app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user || user.password !== password) return res.status(401).json({ error: 'Invalid credentials' });
    const token = `token_${user.id}_${Date.now()}`;
    res.json({ token, user: { id: user.id, email: user.email, name: user.name } });
  } catch (error) { console.error(error); res.status(500).json({ error: 'Internal server error' }); }
});

app.post('/api/bazi/calculate', (req, res) => {
  const { birthYear, birthMonth, birthDay, birthHour, gender } = req.body;
  if (!birthYear || !birthMonth || !birthDay || birthHour === undefined || !gender) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    const result = performCalculation(req.body);
    // basic returns pillars + fiveElements
    res.json({ pillars: result.pillars, fiveElements: result.fiveElements });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Calculation error' });
  }
});

app.post('/api/bazi/full-analysis', requireAuth, (req, res) => {
  const { birthYear, birthMonth, birthDay, birthHour, gender } = req.body;
  if (!birthYear || !birthMonth || !birthDay || birthHour === undefined || !gender) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    const result = performCalculation(req.body);
    res.json(result);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Calculation error' });
  }
});

app.post('/api/bazi/records', requireAuth, async (req, res) => {
  const { birthYear, birthMonth, birthDay, birthHour, gender, birthLocation, timezone } = req.body;

  if (!birthYear || !birthMonth || !birthDay || birthHour === undefined || !gender) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  try {
    const { pillars, fiveElements, tenGods, luckCycles } = performCalculation(req.body);

    const record = await prisma.baziRecord.create({
      data: {
        userId: req.user.id,
        birthYear, birthMonth, birthDay, birthHour, gender,
        birthLocation: birthLocation || null,
        timezone: timezone || null,
        pillars: JSON.stringify(pillars),
        fiveElements: JSON.stringify(fiveElements),
        tenGods: JSON.stringify(tenGods),
        luckCycles: JSON.stringify(luckCycles),
      },
    });

    res.json({ record: serializeRecord(record) });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/bazi/records', requireAuth, async (req, res) => {
  const records = await prisma.baziRecord.findMany({
    where: { userId: req.user.id },
    orderBy: { createdAt: 'desc' },
  });
  res.json({ records: records.map(serializeRecord) });
});

app.delete('/api/bazi/records/:id', requireAuth, async (req, res) => {
  const recordId = Number(req.params.id);
  const record = await prisma.baziRecord.findFirst({
    where: { id: recordId, userId: req.user.id },
  });
  if (!record) return res.status(404).json({ error: 'Record not found' });

  await prisma.favorite.deleteMany({ where: { recordId, userId: req.user.id } });
  await prisma.baziRecord.delete({ where: { id: recordId } });
  res.json({ status: 'ok' });
});

app.post('/api/favorites', requireAuth, async (req, res) => {
  const { recordId } = req.body;
  if (!recordId) return res.status(400).json({ error: 'Record ID required' });

  const record = await prisma.baziRecord.findFirst({ where: { id: recordId, userId: req.user.id } });
  if (!record) return res.status(404).json({ error: 'Record not found' });

  const favorite = await prisma.favorite.upsert({
    where: { userId_recordId: { userId: req.user.id, recordId } },
    update: {},
    create: { userId: req.user.id, recordId },
  });

  res.json({ favorite });
});

app.get('/api/favorites', requireAuth, async (req, res) => {
  const favorites = await prisma.favorite.findMany({
    where: { userId: req.user.id },
    include: { record: true },
    orderBy: { createdAt: 'desc' },
  });
  res.json({
    favorites: favorites.map((favorite) => ({
      ...favorite,
      record: serializeRecord(favorite.record),
    })),
  });
});

app.delete('/api/favorites/:id', requireAuth, async (req, res) => {
  const favoriteId = Number(req.params.id);
  const favorite = await prisma.favorite.findFirst({ where: { id: favoriteId, userId: req.user.id } });
  if (!favorite) return res.status(404).json({ error: 'Favorite not found' });

  await prisma.favorite.delete({ where: { id: favoriteId } });
  res.json({ status: 'ok' });
});


app.post('/api/bazi/ai-interpret', requireAuth, async (req, res) => {
  const { pillars, fiveElements, tenGods, strength } = req.body;
  if (!pillars) return res.status(400).json({ error: 'Bazi data required' });

  // Simulate AI Delay
  await new Promise(r => setTimeout(r, 1000));

  // Mock AI Response
  const mockResponse = `
## ðŸ”® AI Bazi Analysis

**Day Master:** ${pillars.day.stem} (${pillars.day.elementStem})
**Summary:**
This chart shows a ${pillars.day.elementStem} Day Master born in the month of ${pillars.month.branch} (${pillars.month.elementBranch}).
The Five Elements distribution is:
- Wood: ${fiveElements.Wood}
- Fire: ${fiveElements.Fire}
- Earth: ${fiveElements.Earth}
- Metal: ${fiveElements.Metal}
- Water: ${fiveElements.Water}

**Key Patterns:**
With ${tenGods && tenGods.length > 0 ? tenGods[0].name : 'various Ten Gods'} prominent, this chart suggests a person who is... (AI generated content would go here).

**Advice:**
Focus on balancing your ${fiveElements.Fire > 0 ? 'Fire' : 'missing elements'}.
  `;

  res.json({ content: mockResponse });
});

app.listen(PORT, () => {
  console.log(`BaZi Master API running on http://localhost:${PORT}`);
});
